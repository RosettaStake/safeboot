#!/bin/bash
# Take over from /init once the system has been configured
# and the state attested.  The secret file from the remote attestation server
# will be passed on the command line

#set -x
die() { echo >&2 "$@" ; exit 1 ; }
warn() { echo >&2 "$@" ; }

DEV="/dev/sda"
VOLUME="cryptroot"
MAPPER="/dev/mapper/$VOLUME"
KERNEL="/root/boot/vmlinuz"
INITRD="/root/boot/initrd.img"
KEXEC_EXTRA=""

KEY="$1"
URL="$2"

if [ -z "$KEY" ]; then
	KEY="/tmp/secret.bin"
fi

if [ -z "$URL" ]; then
	URL="http://10.0.2.2:8000/focal-server-cloudimg-amd64.img"
fi


kexec_img() {
	# add the decryption key to initrd by creating a temporary copy
	# the source initrd must be padded to 512 bytes or else the kernel
	# won't look for additional cpio files appended after it.
	TMP_INITRD="/tmp/initrd.img"

	warn "$INITRD: adding secret key"

	dd \
		if="$INITRD" \
		of="$TMP_INITRD" \
		bs=512 \
		conv=sync \
	|| die "$INITRD: unable to copy to /tmp"

	# Append a cpio file with a single rootfs.key file that contains the
	# secret to decrypt the root filesystem.
	mkdir -p /tmp/initrd
	cp "$KEY" /tmp/initrd/rootfs.key \
	|| die "$KEY: unable to copy secret key"

	( cd /tmp/initrd ; echo rootfs.key | cpio -H newc -o ) >> "$TMP_INITRD" \
	|| die "$TMP_INITRD: unable to add $KEY to initrd"

	# Load the official kernel and the modified initrd
	# passing in the command line arguments to decrypt the
	# encrypted disk, and then mount the real root filesystem
	# by label.
	KEXEC_CMDLINE="\
console=ttyS0 \
root=LABEL=cloudimg-rootfs \
ro \
cryptopts=target=rootfs,source=/dev/sda,key=/rootfs.key,luks,discard \
$KEXEC_EXTRA \
"
	warn "$KERNEL: $KEXEC_CMDLINE"

	kexec \
		--load "$KERNEL" \
		--initrd "$TMP_INITRD" \
		--command-line "$KEXEC_CMDLINE" \
	|| die "$KERNEL: unable to load with kexec"

	kexec -e

	# if we end up here, we're in trouble...
	die "$KERNEL: kexec failed"
}

mount_img() {
	mkdir -p /run/cryptsetup

	warn "$DEV: unlocking with secret key"
	cryptsetup luksOpen \
		--key-file "$KEY" \
		"$DEV" \
		"$VOLUME"
}

install_img() {
	if [ -e "$MAPPER" ]; then
		cryptsetup luksClose "$VOLUME"
	fi

	#blockdev --setrw "$DEV"

	warn "$DEV: formatting with secret key"
	cryptsetup luksFormat \
		--pbkdf pbkdf2 \
		--batch-mode \
		--label="$VOLUME" \
		"$DEV" \
		"$KEY" \
	|| die "$DEV: luksFormat failed"

	mount_img \
	|| die "$DEV: luksOpen failed"

	warn "$MAPPER: fetching disk image"
	curl "$URL" > "$MAPPER" \
	|| die "$DEV: unable to fetch $URL"

	#blockdev --rereadpt "$MAPPER"

	echo "$MAPPER: File system installed"

	mount "$MAPPER" /root \
	|| die "$MAPPER: unable to mount?"

	# stash the server configuration in the encrypted /boot
	# TODO: deliver this as part of the attestation secret?
	warn "cloud-init: creating user-data"
	KEXEC_EXTRA="$KEXEC_EXTRA ds=nocloud;s=file:///boot/cloud-init/"
	mkdir -p /root/boot/cloud-init
	cat > /root/boot/cloud-init/user-data <<EOF
#cloud-config
hostname: safeboot-demo
chpasswd:
  expire: False
  list: |
    root:password
    ubuntu:password
EOF

	cat > /root/boot/cloud-init/meta-data <<EOF
{"instance-id": "iid-local01"}
EOF

	# remove our write permissions
	mount -o ro,remount /root
}


# ensure that we don't accidentally touch the root device
# this breaks fsck, which is a problem
#blockdev --setro /dev/sda

# attempt to decrypt the disk; if this fails, reinstall an image
if ! mount_img || ! mount -o ro "$MAPPER" /root ; then
	warn "-------------------------------"
	warn "Unable to unlock and mount disk"
	warn "-------------------------------"

	read -r -n 1 -t 10 -p "Press any key to stop reinstall..." response
	if [ -n "$response" ]; then
		exit 0
	fi

	warn "No init in root filesystem, reinstalling"
	install_img
else
	echo "$MAPPER: unlock and mount successful"
fi

if [ ! -e "$KERNEL" ]; then
	die "$KERNEL: No kernel present in image?"
fi

read -r -n 1 -t 3 -p "Press any key to stop autoboot..." response
if [ -n "$response" ]; then
	exit 0
fi

kexec_img

die "kexec failed and we ended up here?"
