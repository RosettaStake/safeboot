#!/bin/bash
# demo server init:
# this is PXE booted, performs a remote attestation, and then
# hands off control to the the real OS stored on a fully encrypted disk.
# if there are any problems, drops to a serial console shell

/bin/busybox --install /bin
mkdir -p /proc /sys /tmp /dev /etc /root /run /boot
mount -t proc none /proc
mount -t devtmpfs none /dev
mount -t sysfs none /sys
mount -t efivarfs none /sys/firmware/efi/efivars
mount -t securityfs none /sys/kernel/security

echo "Hello, initrd" > /dev/console
echo "Hello, initrd (ttyprintk)" > /dev/ttyprintk
exec < /dev/console >/dev/console 2>/dev/console

# load modules that are not built into the kernel
# and bring up the network
#insmod /lib/modules/libahci.ko
#insmod /lib/modules/ahci.ko
#insmod /lib/modules/dm-crypt.ko
#insmod /lib/modules/e1000.ko

# should do dhcp?
ifconfig eth0 10.0.2.15

# check the hash of the kernel/initrd/cmdline that was booted
tpm2 pcrread sha256:4

# cache the eventlog for easy analysis
cat /sys/kernel/security/tpm0/binary_bios_measurements > /tmp/eventlog.bin

# try to unlock the TPM, since swtpm tends to not shutdown cleanly
tpm2 dictionarylockout --clear-lockout

# remotely attest and get a secret disk key
export SERVER="10.0.2.2"
while true; do
	#ping -w 5 -c 1 "$SERVER" \
	#
	ping "$SERVER" \
	|| break

	echo "network is up"
	tpm2-attest \
		attest "http://$SERVER:8080/attest/" \
		> /tmp/secret.bin \
	|| break;

	cat <<EOF
  ----------------------------
    ┏━┓╺┳╸╺┳╸┏━╸┏━┓╺┳╸┏━╸╺┳┓
    ┣━┫ ┃  ┃ ┣╸ ┗━┓ ┃ ┣╸  ┃┃
    ╹ ╹ ╹  ╹ ┗━╸┗━┛ ╹ ┗━╸╺┻┛
  ----------------------------
EOF

	# Invoke the boot script with the new secret
	if [ -x "/bin/bootscript" ]; then
		/bin/bootscript /tmp/secret.bin
	fi

	break;
done


echo "FAILED!!!"

if [ $$ != 1 ]; then
	exit 1
fi

# try to spawn a rescue shell
export PS1='\h:\w# '

if [ -x /bin/setsid ] && [ -x /bin/bash ]; then
	exec setsid -c /bin/bash </dev/console >/dev/console 2>/dev/console
fi

echo "Fallback shell!"
exec /bin/sh </dev/console >/dev/console 2>/dev/console
