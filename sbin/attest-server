#!/usr/bin/python3
"""
Simple server example for receiving attestation quotes,
validating them, and sending back sealed data.
"""
from http.server import BaseHTTPRequestHandler, HTTPServer
import os
import logging
import tempfile
import sys
import subprocess
import yaml
import sqlite3
import hashlib

# hard code the hashing algorithm used
alg = 'sha256'

# sqlite database of hosts and pcrs, indexed by ekhash
db = None

# Check that all of the required PCRs are present and match the golden values.
# It is ok if the quote or event log have more, but none must be missing.
def pcr_validate(golden, quote):
	if alg not in quote:
		print("Quote does not have PCR algorithm '%s'" % (alg))
		return false

	quote = quote[alg]
	valid = True

	for pcr in golden:
		good_pcr = int(golden[pcr], 16)
		if not pcr in quote:
			print("PCR%d missing" % (pcr), file=sys.stderr)
			valid = False
		elif good_pcr != quote[pcr]:
			print("PCR%d mismatch %x != expected %x" % (pcr, quote[pcr], good_pcr), file=sys.stderr)
			valid = False

	return valid


class AttestServer(BaseHTTPRequestHandler):
	def fail(self, msg):
		logging.info("FAILED: ", msg)
		self.send_response(401)
		self.send_header('Content-type', 'text/html')
		self.end_headers()
		self.wfile.write(msg.encode())

	def do_GET(self):
		logging.info("GET request,\nPath: %s\nHeaders:\n%s\n", str(self.path), str(self.headers))
		self.send_response(200)
		self.send_header('Content-type', 'text/html')
		self.end_headers()
		self.wfile.write("Only POST is supported".encode())

	def do_POST(self):
		content_length = int(self.headers.get('Content-Length',0))
		quote_data = self.rfile.read(content_length)

		# write post data into a file
		tmp_file = tempfile.NamedTemporaryFile()
		tmp_file.write(quote_data)
		tmp_file.flush()
		quote_file = tmp_file.name

		# verify that the Endorsment Key came from an authorized TPM,
		# that the quote is signed by a valid Attestation Key
		sub = subprocess.run(["./sbin/tpm2-attest", "verify", quote_file ],
			stdout=subprocess.PIPE,
			stderr=sys.stderr,
		)
		if sub.returncode != 0:
			return self.fail("QUOTE-VERIFY FAILED")

		# The output contains YAML formatted hash of the EK and the PCRs
		quote = yaml.safe_load(sub.stdout)
		ekhash = quote['ekhash']
		cur = db.cursor()
		cur.execute("SELECT secret,device FROM hosts WHERE ekhash = ?", (ekhash,))
		row = cur.fetchone()
		
		if row is None:
			return self.fail("UNKNOWN TPM EK " + ekhash)
		secret = row[0]
		device = row[1]

		logging.info("%s: EK %s" % (device, ekhash))

		cur.execute("SELECT pcr,value FROM pcrs WHERE ekhash = ?", (ekhash,))
		valid_pcrs = {}
		for row in cur.fetchall():
			valid_pcrs[row[0]] = row[1]

		if not pcr_validate(valid_pcrs, quote['pcrs']):
			return self.fail("QUOTE-PCR FAILED")
		if not pcr_validate(valid_pcrs, quote['eventlog-pcrs']):
			return self.fail("EVENTLOG-PCR FAILED")

		# the quote, eventlog and PCRS are valid, so seal some data and return it as binary
		self.send_response(200)
		self.send_header('Content-type', 'application/octet-stream')
		self.end_headers()

		subprocess.run(["./sbin/tpm2-attest", "seal", quote_file, ],
			input=secret.encode(),
			stdout=self.wfile,
			stderr=sys.stderr,
		)

def run(port=8080):
	logging.basicConfig(level=logging.INFO)
	server_address = ('', port)
	httpd = HTTPServer(server_address, AttestServer)
	logging.info('Starting attestation httpd port %d...\n' % (port))
	try:
		httpd.serve_forever()
	except KeyboardInterrupt:
		pass
	httpd.server_close()
	logging.info('Stopping httpd...\n')

if __name__ == '__main__':
	from sys import argv

	if len(argv) <= 2:
		print("Usage: attest-server database.db cmd...", file=sys.stderr)
		exit(1)

	db = sqlite3.connect(argv[1])
	db.execute("""
		CREATE TABLE IF NOT EXISTS hosts (
			ekhash CHAR(64) PRIMARY KEY,
			device TEXT,
			secret BLOB
		)
	""")
	db.execute("""
		CREATE TABLE IF NOT EXISTS pcrs (
			ekhash CHAR(64) PRIMARY KEY,
			pcr INTEGER,
			value CHAR(64),
			FOREIGN KEY (ekhash) REFERENCES hosts (ekhash)
		)
	""")

	if argv[2] == "register":
		# register ek.pub name < secret.bin
		with open(argv[3],"rb") as ekpub:
			# compute the "name" of the ekpub
			ekhash = hashlib.sha256(ekpub.read()).hexdigest()
		host = argv[4]
		secret = sys.stdin.read()
		print(ekhash + ": " + host)
		cur = db.cursor()
		cur.execute("INSERT OR REPLACE INTO hosts(ekhash, device, secret) VALUES(?,?,?)",
			(ekhash, host, secret))
		db.commit()
		cur.execute("SELECT * FROM hosts WHERE ekhash = ?", (ekhash,))
		print(cur.fetchall())
		db.close()
		exit(0)

	if argv[2] == "predictpcr":
		# predictpcr ek.pub index digest ....
		# this is predicts the eventual PCR value based on the hashes
		# that are extended into the PCR. it does not take the final PCR value
		with open(argv[3],"rb") as ekpub:
			# compute the "name" of the ekpub
			ekhash = hashlib.sha256(ekpub.read()).hexdigest()
		pcrindex = argv[4]

		# extend operation is NewPCR = SHA256(PCR || SHA256(newdata))
		# this takes in the hash of the values, so the second SHA256 is not used
		pcr = bytearray(32)
		for newhash in argv[5:]:
			pcr = hashlib.sha256(pcr + bytes.fromhex(newhash)).digest()
		pcr = pcr.hex()
		cur = db.cursor()
		cur.execute("INSERT OR REPLACE INTO pcrs(ekhash, pcr, value) VALUES(?,?,?)",
			(ekhash, pcrindex, pcr))
		db.commit()
		db.close()

		print(ekhash + ": " + pcrindex + "=" + pcr)
		exit(0)

	if argv[2] == "run":
		if len(argv) == 4:
			run(port=int(argv[3]))
		else:
			run()
		exit(0)

	print("Unknown command: '" + argv[2] + "'", file=sys.stderr)
	exit(1)
