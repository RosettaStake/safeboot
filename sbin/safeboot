#!/bin/bash
# Safer Booting with UEFI Secure Boot and the TPM
#
# Be careful with this, it is possible to lock yourself
# out of your computer if you lose the firmware password
# and platform signing keys.
#
# For more details: https://safeboot.dev/
#
# External programs required:
# [ echo openssl tar tpm2 xxd sha256sum tail cut tr dd awk efivar_write
# mount cryptsetup bash objcopy mkdir cat cp gzip
# grep veritysetup tee umount sync sleep reboot telinit fsck.ext4
# blockdev lsof xargs lvcreate mv rm ln lvm mktemp chmod pidof time
# date printf chattr tee cmp
#
# optional programs:
# yubico-piv-tool cert-to-efi-sig-list sign-efi-sig-list.safeboot
# efibootmgr sbsign.safeboot
#
# turn off "expressions don't expand in single quotes"
# and "can't follow non-constant sources"
# shellcheck disable=SC2016 disable=SC1091
set -e -o pipefail
export LC_ALL=C

: "${PREFIX:=}"
: "${DIR:=/etc/safeboot}"

# shellcheck source=functions.sh
. "$PREFIX$DIR/functions.sh"

if [ -r "$PREFIX$DIR/safeboot.conf" ]; then
	# shellcheck source=safeboot.conf
	. $PREFIX$DIR/safeboot.conf
else
	warn "$PREFIX$DIR/safeboot.conf not present; was it installed?"
fi
if [ -r "$PREFIX$DIR/local.conf" ]; then
	# shellcheck source=local.conf
	. $PREFIX$DIR/local.conf
fi

# Apply $PREFIX to files and use default value
CERT=$PREFIX${CERT:-$DIR/cert.pem}
KERNEL=$PREFIX${KERNEL:-/boot/vmlinuz}
INITRD=$PREFIX${INITRD:-/boot/initrd.img}
EFIDIR=$PREFIX${EFIDIR:-/boot/efi/EFI}
ESP_LIST="/etc/kernel/proxmox-boot-uuids"
MANUAL_KERNEL_LIST="/etc/kernel/pve-efiboot-manual-kernels"

# KEY is a normal file, don't use an openssl engine
KEY=$PREFIX${KEY:-$DIR/cert.priv}

# Set the default values for the other parameters
: "${LINUX_TARGET:=linux}"
: "${SIP:=0}"
: "${PCRS:=0,2,5,7}"
: "${BOOTMODE_PCR:=14}"
: "${LINUX_COMMANDLINE:=}"
: "${RECOVERY_COMMANDLINE:=${LINUX_COMMANDLINE}}"
: "${SEAL_PIN:=1}"

usage='
# Safe Boot subcommands

Usage: `safeboot subcommand [options...]`

'

commands="commands"

commands() {
	echo "$usage"
	exit 0
}

show_help() {
	if [ "$1" == "-h" ] || [ "$1" == "--help" ]; then
		echo "$2"
		exit 0
	fi
}

########################################

key_init_usage='
## key-init
Usage:
```
safeboot key-init "subject"
```

Generate a new x509 signing key with openssl, writing storing
the public key in `/etc/safeboot/cert.pem` and the password
protected private key in `/etc/safeboot/signing.key`.
This is not as secure as storing it in a hardware token,
although if the key is moved to an external device and the
`$KEY` variable in `/etc/safeboot/local.conf` updated to point
to it, then it will prevent a software-only attack.

The subject must be written as a "distinguished name":
```
       /CN=host.example.com/OU=test/O=example.com/
```
'
usage+=$key_init_usage

key-init() {
	show_help "$1" "$key_init_usage"
	if [ $# == 0 ]; then
		die "$key_init_usage"
	fi

	subject="$1"

	if [ "$KEY" == "pkcs11:" ]; then
		warn "\$KEY=pkcs11:; updating in local.conf"
		(
			echo "# Added by key-init"
			echo "KEY=$DIR/signing.key"
		) >>"$PREFIX$DIR/local.conf" ||
			die "Unable to update safeboot.conf"
		KEY="$PREFIX$DIR/signing.key"
	fi
	if [ -r "$KEY" ]; then
		read -r -p "WARNING: This will erase the existing key $KEY. Are you sure? " really_do_it
		if [ "$really_do_it" != "y" ]; then
			die "Not overwriting existing key"
		fi

		warn "$KEY: backing up to $KEY.orig"
	fi

	mkdir -p "$(dirname "$KEY")" "$(dirname "$CERT")"

	if [ -r "$KEY" ]; then
		mv "$KEY" "$KEY.orig" ||
			die "$KEY: unable to backup"
	fi
	if [ -r "$CERT" ]; then
		mv "$CERT" "$CERT.orig" ||
			die "$CERT: unable to backup"
	fi

	openssl req \
		-new \
		-x509 \
		-newkey "rsa:2048" \
		-subj "$subject" \
		-keyout "$KEY" \
		-outform "PEM" \
		-out "$CERT" \
		-days "3650" \
		-sha256 ||
		die "$KEY: unable to create"

	# Create a certificate and public key file from the PEM
	pem2der "$CERT"
}

########################################

pem2der() {
	crt_file="${1/.pem/.crt}"
	pub_file="${1/.pem/.pub}"

	warn "$crt_file: Creating from $1"
	openssl x509 \
		-outform der \
		-in "$1" \
		-out "$crt_file" ||
		die "$crt_file: Unable to create DER file from $1"

	warn "$pub_file: Creating from $1"
	openssl x509 \
		-in "$1" \
		-noout \
		-pubkey \
		-out "$pub_file" ||
		die "$pub_file: Unable to create PUB file from $1"
}

########################################

uefi_sign_keys_usage='
## uefi-sign-keys
Usage:
```
safeboot uefi-sign-keys
```

Create three signed certificates for the PK, KEK, and db using
the attached Yubikey or x509 key stored in `/etc/safeboot/signing.key`
and store them in the UEFI SecureBoot configuration.  You should
have run `safeboot yubikey-init` or `safeboot key-init` to have
already generated the keys.

Due to an issue with the OpenSSL PKCS11 engine, you will have to authenticate
to the Yubikey multiple times during this process.
'

usage+=$uefi_sign_keys_usage
commands+="|uefi-sign-keys"

uefi-sign-keys() {
	show_help "$1" "$uefi_sign_keys_usage"

	cert-to-efi-sig-list \
		-g "$(uuidgen)" \
		"$CERT" \
		"$TMP/cert.esl" ||
		die "cert-to-efi-sig-list failed"

	## Cache the yubico pin since it will be used multiple times
	#read -s -p 'Yubikey login PIN: ' pin
	#echo

	# Use the sign-efi-sig-list from our build so that the
	# -e option exists
	for key in db KEK PK; do
		warn "Signing UEFI variable $key"
		sign-efi-sig-list \
			-k "$KEY" \
			-c "$CERT" \
			"$key" \
			"$TMP/cert.esl" \
			$PREFIX$DIR/$key.auth ||
			die "$key: Signing failed"
	done

	uefi-set-keys ""
}

########################################

uefi_set_keys_usage='
## uefi-set-keys
Usage:
```
safeboot uefi-set-keys
```

Store the PK, KEK, and db into the UEFI Secure Boot configuration
variables.  This must be done once during system setup or if a new
key is generated.  The `uefi-sign-key` subcommand attempts to do
this automatically.
'

usage+=$uefi_set_keys_usage
commands+="|uefi-set-keys"

uefi-set-keys() {
	show_help "$1" "$uefi_set_keys_usage"

	# The order of update must be from lowest to highest
	for key in db KEK PK; do
		if [ ! -r "$PREFIX$DIR/$key.auth" ]; then
			die "$PREFIX$DIR/$key.auth not found: run safeboot uefi-sign-keys"
		fi

		warn "Installing UEFI variable $key"

		efi-updatevar -f "$PREFIX$DIR/$key.auth" "$key" ||
			die "$key: updating key failed; is the BIOS in setup mode?"
	done
}

########################################

pcrs_sign_usage='
## pcrs-sign
Usage:
safeboot pcrs-sign [prevent-rollback] [path-to-unified-kernel]

Generate a signature for the PCRs that can be used to unseal the LUKS key
according to the policy created by `safeboot luks-seal`.  The PCRs used
are specified in the `/etc/safeboot/safeboot.conf` or `local.conf` files, and
must match the values that were configured during `luks-seal`.

If the prevent-rollback argument is `prevent-rollback`, the TPM version counter
will be incremented, which will invalidate all previous PCR signatures and prevent
the older unified kernel images from being able to unseal the PCR data.

The signature is persisted in a UEFI NVRAM variable, defined in `safeboot.conf`.
'
usage+="$pcrs_sign_usage"
commands+="|pcrs-sign"

pcrs-sign() {
	show_help "$1" "$pcrs_sign_usage"

	prevent_rollback="${1}"
	# target="${2-linux}"
	VER="${2}"

	if [ "$prevent_rollback" = "prevent-rollback" ]; then
		warn "$linux: Incrementing TPM version to prevent rollback"
		tpm2 nvincrement \
			"$TPM_NV_VERSION" \
			>>/tmp/tpm.log ||
			die "Unable to increment TPM version $TPM_NV_VERSION"
	fi

	tpm2 nvread \
		"$TPM_NV_VERSION" \
		--size 8 \
		>"$TMP/nv_version.bin" ||
		die "Unable to read TPM version $TPM_NV_VERSION"
	VERSION="$(xxd -g8 "$TMP/nv_version.bin" | awk '{print $2}')"
	warn "$linux: TPM version $VERSION"

	# If pre-computed PCRs are known, they can be used here instead
	# TODO: allow PCRs to be passed in

	cat "${ESP_LIST}" | while IFS= read -r curr_uuid; do
		if [ -z "$curr_uuid" ]; then
			continue
		fi
		if ! (echo "${curr_uuid}" | grep -qE '[0-9a-fA-F]{4}-[0-9a-fA-F]{4}'); then
			warn "WARN: ${curr_uuid} read from ${ESP_LIST} does not look like a VFAT-UUID - skipping"
			return
		fi
		path="/dev/disk/by-uuid/$curr_uuid"

		dev="$(lsblk -no pkname $path)"

		if [ ! -e "${path}" ]; then
			warn "WARN: ${path} does not exist - clean '${ESP_LIST}'! - skipping"
			return
		fi
		mountpoint="$TMP/${curr_uuid}"
		mkdir -p "${mountpoint}" ||
			{
				warn "creation of mountpoint ${mountpoint} failed - skipping"
				return
			}
		mount "${path}" "${mountpoint}" ||
			{
				warn "mount of ${path} failed - skipping"
				return
			}

		if [ -z "$VER" ]; then
			BOOT_KVERS="$(boot_kernel_list "$VER")"
		else
			BOOT_KVERS="$(boot_kernel_list)"
		fi

		for kver in ${BOOT_KVERS}; do
			tpm2 pcrread -o "$TMP/pcrs.bin" "sha256:$PCRS" ||
				die "Unable to read TPM PCRs"
			linux="$mountpoint/$EFIDIR/$LINUX_TARGET/$kver/linux.efi"
			vmlinuz="/boot/vmlinuz-$kver"
			echo $vmlinuz
			# Check to see if the PCR4 matches the expected value
			# for the Linux kernel (which will be loaded as the boot application).
			# This works on the Thinkpad X1, which extends PCR4
			# with EFI_EV_SEPARATOR and then the PE hash of the EFI_BOOT_APPLICATION
			linux_hash="$(sbsign.safeboot --hash-only "$linux" || die "unable to hash")"
			vmlinuz_hash="$(sbsign.safeboot --hash-only "$vmlinuz" || die "unable to hash")"
			echo $linux_hash
			echo $vmlinuz_hash
			ev_sep="$(echo "00000000" | hex2bin | tpm2_trial_extend 0)"
			#pcr4_computed="$(echo -n "${ev_sep}${linux_hash}" | hex2bin | sha256)"

			ev_act="$(echo -n "Calling EFI Application from Boot Option" | tpm2_trial_extend 0)"
			ex_ev_sep="$(echo "00000000" | hex2bin | tpm2_trial_extend "$ev_act")"
			pcr4_computed="$(echo -n "${ex_ev_sep}${linux_hash}" | hex2bin | sha256)"
			pcr4_computed="$(echo -n  "${pcr4_computed}${vmlinuz_hash}" | hex2bin | sha256)"
			# Predict pcr5
			gpt_header="$(dd if=/dev/$dev bs=1 skip=512 count=92 | xxd -p | tr -d '\n')"
			number_of_partitions="$(ls /sys/block/$dev/*/partition | wc -l)"
			partitions_entries_size="$(($number_of_partitions * 128))"
			gpt_entries="$(dd if=/dev/$dev bs=1 skip=1024 count=$partitions_entries_size | xxd -p | tr -d '\n')"
			number_of_partitions_hex="$(printf "%02X00000000000000" $number_of_partitions)"
			gpt_hash="$(echo -n "$gpt_header$number_of_partitions_hex$gpt_entries" | hex2bin | sha256)"
			pcr5_computed="$(echo -n "$ev_sep$gpt_hash" | hex2bin | sha256)"
			#pcr5_computed="$(echo -n "Exit Boot Services Returned with Failure" | tpm2_trial_extend $pcr5_computed)"
			pcr5_computed="$(echo -n "Exit Boot Services Invocation" | tpm2_trial_extend $pcr5_computed)"
			pcr5_computed="$(echo -n "Exit Boot Services Returned with Success" | tpm2_trial_extend $pcr5_computed)"

			pcr3_read="$(tpm2 pcrread sha256:3 | tail -1 | cut -c9- | tr '[:upper:]' '[:lower:]')"
			pcr4_read="$(tpm2 pcrread sha256:4 | tail -1 | cut -c9- | tr '[:upper:]' '[:lower:]')"
			pcr5_read="$(tpm2 pcrread sha256:5 | tail -1 | cut -c9- | tr '[:upper:]' '[:lower:]')"

			# HACK: this assumes PCR3 is the second in the list
			# if [ "$pcr3_read" != "$ev_sep" ]; then
			# 	warn "PCR2: ignoring BootMenu entries"
			# 	echo -n "$ev_sep" | hex2bin |
			# 		dd \
			# 			of="$TMP/pcrs.bin" \
			# 			conv=notrunc \
			# 			seek=1 \
			# 			bs=32 \
			# 			2>/dev/null ||
			# 		die "$TMP/pcrs.bin: unable to update PCR2"
			# fi

			warn "$linux: PE hash $linux_hash"

			if [ "$pcr4_computed" == "$pcr4_read" ]; then
				warn "PCR4 unchanged"
			else
				warn "PCR4 $pcr4_computed"

				# HACK: replace the PCR with the computed one, assuming PCR14 is the 3rd
				# initrd dd does not support iflag=fullblock status=none
				echo -n "$pcr4_computed" | hex2bin |
					dd \
						of="$TMP/pcrs.bin" \
						conv=notrunc \
						seek=2 \
						bs=32 \
						2>/dev/null ||
					die "$TMP/pcrs.bin: unable to update PCR4"
			fi

			if [ "$pcr5_computed" == "$pcr5_read" ]; then
				warn "PCR5 unchanged"
			else
				warn "PCR5: $pcr5_computed"
				echo -n "$pcr5_computed" | hex2bin |
					dd \
						of="$TMP/pcrs.bin" \
						conv=notrunc \
						seek=3 \
						bs=32 \
						2>/dev/null ||
					die "$TMP/pcrs.bin: unable to update PCR5"
			fi

			# Add a "normal" entry for PCR 14, which ensures that the TPM
			# will only unseal during a normal boot, not a recovery boot.
			# the unseal script will also extend PCR14 after unsealing
			# to prevent the TPM from unsealing the secret a second time
			#
			# TODO: Fix the ordering if the boot mode PCR is not the last on the list
			pcr14="$(echo -n "${LINUX_TARGET}" | tpm2_trial_extend "$PCR_DEFAULT")"
			warn "mode=${LINUX_TARGET} PCR$BOOTMODE_PCR=$pcr14"
			echo -n "$pcr14" | hex2bin \
				>>"$TMP/pcrs.bin"
			echo "final PCRs:"
			xxd -g32 -c32 "$TMP/pcrs.bin" | awk '{print $2}'

			tpm2_create_policy "$TMP/pcrs.bin" "$VERSION"

			openssl dgst \
				-sha256 \
				-sign "$KEY" \
				-out "$TMP/pcr.policy.sig" \
				"$TMP/pcr.policy" ||
				die "Unable to sign PCR policy"

			efivar_write "${LINUX_TARGET}-$curr_uuid-$kver-$PCR_SIGNATURE" <"$TMP/pcr.policy.sig" ||
				die "${LINUX_TARGET}-$curr_uuid-$kver-$PCR_SIGNATURE: Unable to write to EFI variable"

		done
		umount "${mountpoint}" ||
			{
				warn "umount of ${path} failed - failure"
				exit 0
			}
	done
}

luks_seal_usage='
## luks-seal
Usage:
```
safeboot luks-seal
```

This will generate a new LUKS encryption key for the block device in
`/etc/crypttab` and requires an existing recovery key to install the
new key slot.  You will also be prompted for an unlock PIN, which will
be required on the next normal boot in place of the recovery code.

If this is the first time the disk has been sealed, `/etc/crypttab`
will be updated to include a call to the unsealing script to retrieve
the keys from the TPM, and a counter will be created to prevent rollbacks.

After sealing the secret, the initrd will be rebuild, the kernel signed,
and the new predicted PCRs signed.  Any previous sealed data will be
invalidated since the version counter will be incremented.

Right now only a single crypt disk is supported.

'

usage+=$luks_seal_usage
commands+="|luks-seal"

luks-seal() {
	show_help "$1" "$luks_seal_usage"

	if [ -n "$1" ]; then
		PCRS="$1"
		shift
	fi
	if [ -n "$1" ]; then
		BOOTMODE_PCR="$1"
		shift
	fi

	KEYSLOT=1

	# check to see if the initramfs hook is installed
	if [ ! -x "$PREFIX/etc/initramfs-tools/hooks/safeboot-hooks" ]; then
		warn "!!! $PREFIX/etc/initramfs-tools/hooks/safeboot-hooks is not installed; this will probably not work"
	fi

	# and make sure that the unlock script is installed as expected
	if [ ! -x "$PREFIX/usr/sbin/safeboot" ]; then
		warn "!!! $PREFIX/usr/sbin/safeboot is not installed; this will probably not work"
	fi


	#	if [ "$(wc -l < "$PREFIX/etc/crypttab")" -ne 1 ]; then
	#		die "!!! $PREFIX/etc/crypttab must have only one entry"
	#	fi

	# Determine which device is the cryptdisk
	#uuid="$(cut -d' ' -f2 $PREFIX/etc/crypttab)"
	#if [ -z "$uuid" ]; then
	#		die "Unable to find UUID in crypttab"
	#	fi
	#	dev=$(blkid -U "${uuid#UUID=}")
	#	if [ -z "$dev" ]; then
	#		die "Unable to find device for $uuid"
	#	fi

	uuid="$(cut -d' ' -f2 $PREFIX/etc/crypttab)"
	if [ -z "$uuid" ]; then
		die "Unable to find UUID in crypttab"
	fi
	list=($uuid)
	devs=()
	for v in "${list[@]}"; do
		t=$(blkid -U "${v#UUID=}")
		if [ -z "$t" ]; then
			die "Unable to find device for $v"
		fi
		devs+=($t)
	done
	# Use a tmpfs mount instead of just a temp directory so that
	# the disk encryption key doesn't touch a persistent disk.
	mount_tmp
	# The PCR contents are not important here, only the list of them.
	# The signed PCR values created by pcrs_sign will be used for unsealing
	# the contents, not these values
	# Ask for a PIN that will be used to decrypt, if configured
	if [ "$SEAL_PIN" = "1" ]; then
		while true; do
			read -r -s -p "New unsealing PIN: " SEAL_PIN1
			echo
			if [ "$SEAL_PIN1" = "" ]; then
				echo >&2 'PIN must not be empty, unset $SEAL_PIN in /etc/safeboot/local.conf instead'
				continue
			fi

			read -r -s -p "Unsealing PIN again: " SEAL_PIN2
			echo
			if [ "$SEAL_PIN1" = "$SEAL_PIN2" ]; then
				break
			fi
		done
	fi

	# Ensure that there is a TPM counter at the desired address
	tpm2 nvundefine \
		"$TPM_NV_VERSION" \
		>>/tmp/tpm.log ||
		warn "Unable to remove old TPM counter $TPM_NV_VERSION"

	tpm2 nvdefine \
		"$TPM_NV_VERSION" \
		--attributes 'authread|authwrite|nt=counter' \
		--size 8 \
		>>/tmp/tpm.log ||
		die "Unable to create TPM counter $TPM_NV_VERSION"

	tpm2 nvincrement \
		"$TPM_NV_VERSION" \
		>>/tmp/tpm.log ||
		die "Unable to initialize TPM counter $TPM_NV_VERSION"

	tpm2_create_policy

	dd \
		if=/dev/urandom \
		of="$TMP/key.bin" \
		bs=32 \
		count=1 \
		iflag=fullblock \
		status=none \
		2>/dev/null ||
		die "Unable to generate random key"

	warn "Sealing secret with TPM, storing sealed secret in $TPM_NV_VERSION"

	tpm2_flushall

	tpm2 createprimary \
		--key-context "$TMP/primary.ctx" \
		>>/tmp/tpm.log ||
		die "Unable to create TPM primary object"

	tpm2 create \
		--parent-context "$TMP/primary.ctx" \
		--policy "$TMP/signed.policy" \
		--sealing-input "$TMP/key.bin" \
		${SEAL_PIN1:+ --key-auth "$SEAL_PIN1" } \
		--public "$TMP/sealed.pub" \
		--private "$TMP/sealed.priv" \
		>>/tmp/tpm.log ||
		die "Unable to create TPM key context"

	tpm2 load \
		--parent-context "$TMP/primary.ctx" \
		--public "$TMP/sealed.pub" \
		--private "$TMP/sealed.priv" \
		--name "$TMP/sealed.name" \
		--key-context "$TMP/sealed.ctx" ||
		die "Unable to load sealed object into TPM"

	tpm2 evictcontrol \
		--hierarchy owner \
		--object-context "$TPM_SEALED_HANDLE" ||
		warn "Unable to evict existing sealed handle $TPM_SEALED_HANDLE, ignoring"

	tpm2 evictcontrol \
		--hierarchy owner \
		--object-context "$TMP/sealed.ctx" \
		"$TPM_SEALED_HANDLE" ||
		die "Unable to persist sealed data into the TPM"

	# make sure the crypttab has the unlock script referenced
	if ! grep keyscript "$PREFIX/etc/crypttab" >/dev/null; then
		warn "adding crypttab unseal script"
		sed \
			-i.orig \
			's: luks: keyscript=/usr/sbin/safeboot-tpm-unseal,luks:' \
			$PREFIX/etc/crypttab ||
			die "$PREFIX/etc/crypttab: unable to add keyscript"

		need_update_initramfs=1
	fi

	# ask for the disk encryption key
	for dev in "${devs[@]}"; do
		for tries in 1 2 3 fail; do
			read -r -s -p "$dev: Current recovery password: " recovery_key
			echo
			echo -n "$recovery_key" >"$TMP/recovery.key"

			warn "Removing old LUKS TPM key (if it exists)"
			cryptsetup luksKillSlot \
				--key-file "$TMP/recovery.key" \
				"$dev" $KEYSLOT ||
				warn "$dev: Unable to remove old key slot (ignored)"

			warn "Adding new LUKS TPM key"
			cryptsetup luksAddKey \
				--key-file "$TMP/recovery.key" \
				--key-slot $KEYSLOT \
				"$dev" "$TMP/key.bin" &&
				break

			warn "$dev: Unable to add key slot"

			if [ $tries == fail ]; then
				die "$dev: Unable to add key"
			fi
		done
	done

	rm -f "$TMP/key.bin"

	warn "$dev: sealed with PCR $PCRS,$BOOTMODE_PCR"

	if [ -n "$need_update_initramfs" ]; then
		warn "-------- Need to update initramfs --------"
		update-initramfs -u ||
			die "Unable to update initramfs"

		warn "-------- Need to sign new kernel --------"
		linux-sign ||
			die "Unable to sign kernel"
	fi

	warn "-------- Need to sign PCR and counter values --------"
	pcrs-sign "allow-rollback" "$LINUX_TARGET" ||
		die "Unable to sign PCRs"
}

########################################

sign_usage='
## sign
Usage:
```
safeboot sign exe [exe.signed]
```

Sign an EFI executable with the safeboot keys.

This is the raw command; you might want to use `safeboot linux-sign` or
`safeboot recovery-sign` instead.
'

usage+=$sign_usage
commands+="|sign"

sign() {
	show_help "$1" "$sign_usage"
	IN="$1"
	if [ -z "$IN" ]; then
		die "$sign_usage"
	fi

	OUT="$2"
	if [ -z "$OUT" ]; then
		OUT="$IN.signed"
	fi

	sbsign.safeboot \
		--key "$KEY" \
		--cert "$CERT" \
		--output "$OUT" \
		"$IN"

	return $?
}

unify_kernel_usage='
## unify-kernel
Usage:
```
safeboot unify-kernel linux.efi kernel=path-to-kernel initrd=path-to-initrd ...
```

Creates a unified kernel image with the named sections and files
(typically `kernel`, `initrd`, `cmdline`, and `osrel`) bundled into
an EFI executable.

This is the raw command; you might want to use `safeboot linux-sign` or
`safeboot recovery-sign` instead to add the EFI boot manager entry.
'

usage+=$unify_kernel_usage
commands+="|unify-kernel"

unify-kernel() {
	show_help "$1" "$unify_kernel_usage"
	unified="$1"

	if [ -z "$unified" ]; then
		die "$unify_kernel_usage"
	fi

	warn "$unified: Creating merged Linux/initrd image"
	shift
	sections=()
	offset=$((0x20000))
	blocksize=$((0x10000))

	# Build the list of sections to add, splitting on = signs
	for section in "$@"; do
		name="${section%=*}"
		file="${section#*=}"
		if [ "$name" = "$section" ]; then
			die "$name: format error (not name=file?)"
		fi
		if [ ! -r "$file" ]; then
			die "$file: unable to read"
		fi

		size="$(wc -c <"$file")"
		warn ".$name=$file: $size @ $offset"

		sections+=(
			--add-section ".$name=$file"
			--change-section-vma ".$name=$offset"
		)

		# round up the offset to the next block size
		offset="$(((offset + size + blocksize - 1) / blocksize * blocksize))"
	done

	objcopy \
		"${sections[@]}" \
		"$PREFIX/usr/lib/systemd/boot/efi/linuxx64.efi.stub" \
		"$unified" ||
		die "$unified: unable to create"
}

########################################

sign_kernel_usage='
## sign-kernel
Usage:
```
safeboot sign-kernel linux.efi [linux.signed.efi]
```

Sign a unified EFI executable with the safeboot keys.  If no destination
is specified it will be the same name as the input kernel with `.signed.efi`
added.

This is the raw command; you might want to use `safeboot linux-sign` or
`safeboot recovery-sign` instead to add the EFI boot manager entry.
'

usage+=$sign_kernel_usage
commands+="|sign-kernel"

sign-kernel() {
	show_help "$1" "$sign_kernel_usage"
	unified="$1"

	if [ -z "$unified" ]; then
		die "$sign_kernel_usage"
	fi

	if [ ! -r "$unified" ]; then
		die "$unified: kernel is not readable"
	fi

	signed="$2"
	if [ -z "$signed" ]; then
		signed="${unified%.efi}.signed.efi"
	fi

	for try in 1 2 3; do
		warn "$signed: Signing (ignore warnings about gaps)"
		sbsign.safeboot \
			--key "$KEY" \
			--cert "$CERT" \
			--output "$signed" \
			"$unified" &&
			break

		if [ "$try" == 3 ]; then
			die "$signed: failed after $try tries"
		fi

		warn "$signed: signature failed! Try $try."
	done

	sbsign.safeboot --hash-only "$signed"
}

########################################

install_kernel_usage='
## install-kernel
Usage:
```
safeboot install-kernel boot-name [extra kernel parameters...]
```

Create an EFI boot menu entry for `boot-name`, with the specified
kernel, initrd and command line bundled into an executable and signed.
This command requires the Yubikey or x509 password to be able to sign
the merged EFI executable.

This is the raw command; you might want to use `safeboot linux-sign` or
`safeboot recovery-sign` instead.
'

usage+=$install_kernel_usage
commands+="|install-kernel"

install-kernel() {
	show_help "$1" "$sign_kernel_usage"
	if [ ! -e ${ESP_LIST} ]; then
		return 2
	fi

	TARGET="$1"
	shift

	VER="$2"
	shift

	if [ -z "$TARGET" ]; then
		die "$sign_kernel_usage"
	fi

	cat "${ESP_LIST}" | while IFS= read -r curr_uuid; do
		if [ -z "$curr_uuid" ]; then
			continue
		fi
		if ! (echo "${curr_uuid}" | grep -qE '[0-9a-fA-F]{4}-[0-9a-fA-F]{4}'); then
			warn "WARN: ${curr_uuid} read from ${ESP_LIST} does not look like a VFAT-UUID - skipping"
			return
		fi
		path="/dev/disk/by-uuid/$curr_uuid"
		if [ ! -e "${path}" ]; then
			warn "WARN: ${path} does not exist - clean '${ESP_LIST}'! - skipping"
			return
		fi
		mountpoint="$TMP/${curr_uuid}"
		mkdir -p "${mountpoint}" ||
			{
				warn "creation of mountpoint ${mountpoint} failed - skipping"
				return
			}
		mount "${path}" "${mountpoint}" ||
			{
				warn "mount of ${path} failed - skipping"
				return
			}

		OUTDIR="${mountpoint}/${EFIDIR}/${TARGET}"

		# manage bootmgr here?

		if [ -z "$VER" ]; then
			BOOT_KVERS="$(boot_kernel_list "$VER")"
		else
			BOOT_KVERS="$(boot_kernel_list)"
		fi

		for kver in ${BOOT_KVERS}; do

			linux_image="/boot/vmlinuz-${kver}"
			initrd="/boot/initrd.img-${kver}"

			if [ ! -d "$OUTDIR/$kver" ]; then
				warn "$OUTDIR: Creating directory on EFI System Partition"
				mkdir -p "$OUTDIR/$kver" ||
					die "$OUTDIR/$kver: unable to create"
			fi

			if [ $# == 0 ]; then
				warn "Using /proc/cmdline"
				"$(cat /proc/cmdline) PCR=$TARGET-$curr_uuid-$kver" >"$TMP/cmdline.txt"
			else
				echo -n "$@ PCR=$TARGET-$curr_uuid-$kver" >"$TMP/cmdline.txt"
			fi

			echo "Kernel commandline: '$(cat "$TMP/cmdline.txt")'"

			if ! efibootmgr | grep "^Boot.* $TARGET-$curr_uuid-$kver\$"; then
				# determine the device the EFI system partition is on
				DEV="$(df "$OUTDIR" | tail -1 | cut -d' ' -f1)"
				part=$(cat /sys/class/block/$(basename $DEV)/partition)

				warn "$OUTDIR: Creating boot menu item on $DEV"
				efibootmgr \
					--quiet \
					--create \
					--disk "$DEV" \
					--part $part \
					--label "$TARGET-$curr_uuid-$kver" \
					--loader "\\${EFIDIR}\\$TARGET\\$kver\\linux.efi" ||
					die "efibootmgr: failed to create $TARGET entry"
			fi

			unify-kernel "$TMP/linux.efi" \
				osrel="$PREFIX/etc/os-release" \
				cmdline="$TMP/cmdline.txt" \
				linux="$linux_image" \
				initrd="$initrd" ||
				die "$TMP/linux.efi: unable to unify image"
			echo "Signing"
			sign-kernel "$TMP/linux.efi" "$OUTDIR/$kver/linux.efi.new" ||
				die "$OUTDIR/$kver/linux.efi: unable to sign"

			# Duplicate the old image and atomically move the new kernel
			# image to avoid potentially leaving an unbootable system
			#if [ -r "$OUTDIR/linux.efi" ]; then
			#	cp "$OUTDIR/linux.efi" "$OUTDIR/linux.efi.old" \
			#	|| die "$OUTDIR/linux.efi.old: unable to backup old image"
			#fi

			mv "$OUTDIR/$kver/linux.efi.new" "$OUTDIR/$kver/linux.efi" ||
				die "$OUTDIR/$kver/linux.efi: unable to install new image"

			sha256sum "$OUTDIR/$kver/linux.efi"
		done

		# Remove old kernels
		for kerneldir in "$OUTDIR"/*; do
			if [ ! -d "${kerneldir}" ]; then
				warn "	${kerneldir} is not a directory - skipping"
				continue
			fi

			kver="$(echo "${kerneldir}" | sed -r "s#^$OUTDIR/(.+)\$#\\1#")"

			echo "${BOOT_KVERS}" | grep -q "${kver}" && continue
			warn "	Removing old version ${kver}"
			rm -rf "${kerneldir}"

			if efibootmgr | grep "^Boot.* $TARGET-$curr_uuid-$kver\$"; then
				# determine the device the EFI system partition is on
				entry="$(efibootmgr | grep "^Boot.* $TARGET-$curr_uuid-$kver\$")"
				entry=${entry##*Boot}
				entry=${entry%%\**} 

				warn "$OUTDIR: Removing boot menu item on $DEV"
				efibootmgr -b $entry -B || die "efibootmgr: failed to remove $TARGET entry"
			fi
			if [ "$TARGET" == "$LINUX_TARGET" ]; then
				efivar_remove "${LINUX_TARGET}-$curr_uuid-$kver-$PCR_SIGNATURE"
			fi
		done

		umount "${mountpoint}" ||
			{
				warn "umount of ${path} failed - failure"
				exit 0
			}
	done
}

########################################

linux_sign_usage='
## linux-sign
Usage:
```
safeboot linux-sign [target-name [parameters...]]
```

Generate dm-verity hashes and then sign the Linux with the root hash added
to the kernel command line.  The default target for the EFI boot manager is
`linux`.  You will need the Yubikey or x509 password to sign the new hashes
and kernel.

If the environment variable `$HASH` is set to the hash value, or if
the `$HASHFILE` variable points to the previous dmverity log (typically
`/boot/efi/EFI/linux/verity.log`), then the precomputed value will be used
instead of recomputing the dmverity hashes (which can take some time).
If the hashes are out-of-date, this might render the `linux` target
unbootable and require a recovery reboot to re-hash the root filesystem.
'

usage+=$linux_sign_usage
commands+="|linux-sign"

linux-sign() {
	show_help "$1" "$linux_sign_usage"
	
	if [ ! -e ${ESP_LIST} ]; then
		return 2
	fi

	# default is linux
	# if [ -n "$1" ]; then
	# 	TARGET=$1
	# 	shift
	# else
	# 	TARGET=${LINUX_TARGET}
	# fi

	if [ -n "$1" ]; then
		VER="$1"
		shift
	else
		VER=""
	fi

	install-kernel "$LINUX_TARGET" \
		"$VER" \
		"$LINUX_COMMANDLINE" \
		"safeboot.mode=$LINUX_TARGET" \
		"$@" ||
		die "Kernel signing failed!"

	if [ -r "$TMP/verity.log" ]; then
		# stash a copy of the verity log in the boot directory
		# so that repeat signing can be done more quickly
		cp "$TMP/verity.log" "$OUTDIR"
	fi
}

bootnext_usage='
## bootnext
Usage:
```
safeboot bootnext Setup
```

Configure the EFI boot manager `BootNext` variable to select an
alternate boot menu item.  This command requires root access to
update the EFI variables.
'

usage+=$bootnext_usage
commands+="|bootnext"

bootnext() {
	show_help "$1" "$bootnext_usage"
	efi_bootnext "${1:-recovery}"
}

kernel_keep_versions() {
	eval "$(apt-config shell DPKG Dir::bin::dpkg/f)"
	test -n "$DPKG" || DPKG="/usr/bin/dpkg"

	list="$("${DPKG}" -l | awk '/^[ih][^nc][ ]+pve-kernel-[0-9]+\./ && $2 !~ /-dbg(:.*)?$/ && $2 !~ /-dbgsym(:.*)?$/ { print $2; }' |
		sed -e 's#^pve-kernel-##' -e 's#:[^:]\+ # #')"

	sorted_list="$(echo "$list" | sort --unique --reverse --version-sort)"

	[ -n "$1" ] && install_version="$1"

	running_version="$(uname -r | tr 'A-Z' 'a-z')"

	# ignore the currently running version if attempting a reproducible build
	if [ -n "${SOURCE_DATE_EPOCH}" ]; then
		running_version=""
	elif [ ! -e "/boot/vmlinuz-$running_version" ]; then
		# ignore the current version if it got removed, the "auto-remove" logic
		# will not be affected, because either it is installed and thus we keep
		# it in the list, or it's already removed anyway
		running_version=""
	fi

	latest_2_versions="$(echo "$sorted_list" | grep -E '^[^ ]+-pve' | head -n2)"

	series_metapackages="$(echo "$sorted_list" | grep -Ev '^[^ ]+-pve' | head -n2)"

	oldseries="$(echo "$series_metapackages" | tail -n1)"
	oldseries_latest_kernel="$(echo "$sorted_list" | grep -E "^${oldseries}\.[^ ]+-pve" | head -n1)"

	if [ -e "$MANUAL_KERNEL_LIST" ]; then
		manual_kernels="$(cat "$MANUAL_KERNEL_LIST")"
	fi

	kernels="$(
		cat <<-EOF
			$running_version
			$install_version
			$manual_kernels
			$latest_2_versions
			$series_metapackages
			$oldseries_latest_kernel
		EOF
	)"

	echo "$kernels" | sort -u | sed -e '/^$/ d'
}

boot_kernel_list() {
	list="$(kernel_keep_versions "$@")"

	echo "$list" | grep -vE '^[0-9]+\.[0-9]+$' || true
}

########################################

if [ $# -lt 1 ]; then
	die "Usage: $0 [$commands] ...."
fi

command=$1
shift
#echo "$commands"

case "$command" in
-h | --help)
	echo "$usage"
	exit 0
	;;
#$commands)
key-init | uefi-sign-keys | uefi-set-keys | luks-seal | pcrs-sign | sign | unify-kernel | sign-kernel | install-kernel | linux-sign | recovery-sign | recovery-reboot | tpm2_trial_extend | bootnext)
	$command "$@"
	;;
*)
	die "$0: subcommand $command unknown"
	;;
esac
